from typing import Optional
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QFormLayout, QLineEdit, QTextEdit,
    QDialogButtonBox, QMessageBox, QSizeGrip, QHBoxLayout
)
from PySide6.QtCore import Qt # Import Qt
from src.data_models import Conflict # Use the existing Conflict model

class CampaignConflictEntryDialog(QDialog):
    def __init__(self, parent, conflict_entry: Optional[Conflict] = None):
        super().__init__(parent)

        self.conflict_to_edit = conflict_entry

        if self.conflict_to_edit:
            self.setWindowTitle("Edit Conflict Entry")
        else:
            self.setWindowTitle("Add New Conflict Entry")

        self.setModal(True)
        self.setMinimumWidth(350) # Adjusted minimum width

        layout = QVBoxLayout(self)
        form_layout = QFormLayout()

        self.title_edit = QLineEdit()
        self.antagonist_edit = QLineEdit()
        self.notes_edit = QTextEdit()
        self.notes_edit.setPlaceholderText("Describe the conflict, key actors, stakes, potential resolutions, etc.")

        form_layout.addRow("Conflict Title/Identifier*:", self.title_edit)
        form_layout.addRow("Adventurers vs. (Antagonist/Situation):", self.antagonist_edit)
        form_layout.addRow("Notes:", self.notes_edit)

        layout.addLayout(form_layout)

        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Save | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.accepted.connect(self._on_save)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

        # Add QSizeGrip for resizing
        sizegrip_layout = QHBoxLayout()
        sizegrip_layout.addStretch(1)
        self.size_grip = QSizeGrip(self)
        sizegrip_layout.addWidget(self.size_grip, 0, Qt.AlignBottom | Qt.AlignRight)
        layout.addLayout(sizegrip_layout)

        if self.conflict_to_edit:
            self._load_conflict_data()

    def _load_conflict_data(self):
        if self.conflict_to_edit:
            self.title_edit.setText(self.conflict_to_edit.title_identifier)
            self.antagonist_edit.setText(self.conflict_to_edit.antagonist_situation)
            self.notes_edit.setHtml(self.conflict_to_edit.notes)

    def _on_save(self):
        title = self.title_edit.text().strip()
        if not title:
            QMessageBox.warning(self, "Validation Error", "Conflict Title/Identifier cannot be empty.")
            return

        # If we are creating a new conflict, self.conflict_to_edit will be None.
        # If we are editing, we update the existing object.
        # The actual addition to the campaign's list or update is handled by the caller.
        self.accept()

    def get_data(self) -> Optional[Conflict]:
        if self.result() == QDialog.DialogCode.Accepted:
            title = self.title_edit.text().strip()
            antagonist = self.antagonist_edit.text().strip()
            notes = self.notes_edit.toHtml().strip()

            if self.conflict_to_edit: # Editing existing entry
                # Update the existing conflict object directly
                self.conflict_to_edit.title_identifier = title
                self.conflict_to_edit.antagonist_situation = antagonist
                self.conflict_to_edit.notes = notes
                return self.conflict_to_edit
            else: # Creating a new entry
                # A new Conflict object will be created by the caller widget,
                # which will then add it to the campaign data.
                # This dialog just provides the raw data.
                # We return a new Conflict object populated with dialog data,
                # but the ID will be generated when the actual Conflict object is made.
                # Or, we can create it here but the caller must be aware.
                # For now, let's return the raw data as a dict, and let the widget create the object.
                # No, sticking to prompt: "get_data() method to return a CampaignConflictEntry instance."
                # In our case, this is a `Conflict` instance.
                return Conflict(
                    title_identifier=title,
                    antagonist_situation=antagonist,
                    notes=notes
                    # conflict_id will be auto-generated by the Conflict dataclass
                )
        return None

    def get_entry_data(self):
        """Return the CampaignConflictEntry instance for saving to the campaign."""
        return self.get_data()

if __name__ == '__main__':
    from PySide6.QtWidgets import QApplication
    # Test adding
    app = QApplication([])
    dialog_add = CampaignConflictEntryDialog(None)
    if dialog_add.exec() == QDialog.DialogCode.Accepted:
        data = dialog_add.get_data()
        print("Add dialog accepted. Data:", data)
        if data:
            print(f"Conflict ID: {data.conflict_id}")

    # Test editing
    existing_conflict = Conflict(title_identifier="Old War", antagonist_situation="The Evil King", notes="Long time ago")
    dialog_edit = CampaignConflictEntryDialog(None, conflict_entry=existing_conflict)
    if dialog_edit.exec() == QDialog.DialogCode.Accepted:
        edited_data = dialog_edit.get_data()
        print("Edit dialog accepted. Data:", edited_data)
        if edited_data:
            print(f"Edited Title: {edited_data.title_identifier}, Original ID: {edited_data.conflict_id}")
            # Verify existing_conflict object was updated
            print(f"Original object after edit: {existing_conflict}")
            assert edited_data is existing_conflict # Should be the same object

    del app
